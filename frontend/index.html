<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Pomodorus</title>
    <link rel="manifest" href="https://raw.githubusercontent.com/zyon-king/MyPomodorus/refs/heads/main/frontend/manifest.json">

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Roboto+Mono:wght@400;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        :root {
            --cor-principal: linear-gradient(-135deg, #0f0e1a, #0a1435, #0f0e1a, #0a1435);
            --cor-secundaria: linear-gradient(135deg, #4b0a0a 0%, #6b0c1e 50%, #3f0b14 100%); /* Vinho Escuro */
            --cor-acento: #993366; /* Tom mais claro de Vinho */
            --cor-texto: #00ccff; /* Azul neon */
            --cor-fundo: linear-gradient(135deg, #000000, #3b0047, #660000, #000000); /* Gradiente de fundo */
            --sombra-leve: 0 4px 6px rgba(0, 0, 0, 0.2);
            --transicao-suave: all 0.3s ease-in-out;
        }
        
        :root {
            --dark-blue: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            --wine: linear-gradient(135deg, #4b0a0a 0%, #6b0c1e 50%, #3f0b14 100%);
            --light-wine: linear-gradient(135deg, #3c0a24 0%, #5e0b35 50%, #3c0a24 100%);
            --text-color: #f0f0f0;
            --border-color: #4a148c;
        }


        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background-image: var(--cor-fundo);
            color: var(--cor-texto);
            /**text-shadow: 0 0 3px rgba(0, 255, 204, 0.8), 0 0 0.5px rgba(0, 255, 204, 0.6);*/
            display: flex; /* Makes the body a flex container */
            flex-direction: column; /* Stacks children vertically */
            justify-content: flex-start; /* Aligns children to the start of the flex container */
            align-items: center; /* Centers children horizontally */
            margin: 0; /* Remove default body margin */
            padding: 0; /* Remove default body padding */
            text-rendering: optimizeLegibility;
        }

        @keyframes slideFromTop {
          from {
            transform: translate(0, -100%); /* começa fora da tela */
            opacity: 0;
          }
          to {
            transform: translate(0, 1.0rem); /* posição normal */
            opacity: 1;
          }
        }
        
        .container {
          top: 0.5rem;
          border-bottom: 5%;
          animation: slideFromTop 0.6s ease forwards;
          
          background-image: var(--cor-principal);
          padding: 3rem 2.5rem;
          border-radius: 15px;
          border: 3px solid rgba(255, 255, 255, 0.2);
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
          max-width: 500px;
          width: 90%;
        }

        form, .form-group {
            display: flex;
            flex-direction: column; /* Este é o ajuste chave */
            align-items: center;
            gap: 0.5rem; /* Adiciona um pequeno espaço entre os itens */
            margin-bottom: 0.5rem;
        }

        .section-title {
            text-align: center;
            margin-bottom: 2rem;
        }

        .section-title h1 {
            font-size: 2.5rem;
            font-weight: 600;
            color: var(--cor-texto);
        }

        .form-group {
            margin-bottom: 0.5rem;
            position: relative;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 1rem;
            font-weight: 400;
            color: var(--cor-texto);
        }

        .form-group input[type="time"], .form-group input[type="text"] {
            width: ;
            padding: 0.5rem 1rem;
            background-image: var(--cor-fundo);
            border: 2px solid var(--cor-principal);
            border-radius: 8px;
            color: var(--cor-texto);
            font-size: 1rem;
            transition: var(--transicao-suave);
            appearance: none;
        }
        
        /* Personalização do input type="time" */
        .form-group input[type="time"]::-webkit-calendar-picker-indicator {
            background-color: var(--cor-acento);
            padding: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: var(--transicao-suave);
        }
        
        .form-group input[type="text"]:focus,
.form-group input[type="time"]:focus {
            outline: none;
            border-color: var(--cor-acento);
            box-shadow: 0 0 0 3px rgba(153, 51, 102, 0.5);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 0.75rem;
            appearance: none;
            width: 20px;
            height: 20px;
            background-color: var(--cor-fundo);
            border: 2px solid var(--cor-acento);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: var(--transicao-suave);
        }

        .checkbox-container input[type="checkbox"]:checked {
            background-color: var(--cor-acento);
            border-color: var(--cor-acento);
        }

        .checkbox-container input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 10px;
            height: 10px;
            background-color: var(--cor-texto);
            border-radius: 2px;
            transform: scale(1);
            transition: var(--transicao-suave);
        }

        .checkbox-container label {
            font-size: 1rem;
            color: var(--cor-texto);
            user-select: none;
        }
        
        .buttons {
            display: flex;
            justify-content: center; /* Centraliza os botões horizontalmente */
            gap: 1rem; /* Adiciona um espaço de 16px entre os botões */
        }
        
        .btn-general {
            width: 50%;
            margin-bottom: 1.8rem;
            padding: 1rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            background: var(--cor-secundaria);
            color: var(--cor-texto);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transicao-suave);
            box-shadow: var(--sombra-leve);

            /* Adicione esta linha: */
            white-space: nowrap; 
        }

        .btn-general:hover {
            background-color: var(--cor-acento);
            transform: translateY(-3px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }
        
        .remove-btn {
            margin-left: 10px;
            padding: 5px 10px;
            background: var(--cor-secundaria);
            color: var(--cor-texto);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .remove-btn:hover {
            background-color: #a04070;
        }
        
        #pauses-list li {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 8px;
            background-color: #2b3a5b; /* Uma cor um pouco mais clara que o fundo */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
                
        /* --- Modal para Popup --- */
        .popup-modal-overlay {
            position: fixed; /* Fixa o elemento na janela de visualização */
            top: 0; /* Começa no topo da tela */
            left: 0;
            width: 100%; /* Ocupa toda a largura */
            height: 100%; /* Ocupa toda a altura da viewport */
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center; /* Centraliza o conteúdo (config-modal-content) horizontalmente */
            align-items: flex-start; /* Alinha o conteúdo (config-modal-content) no topo */
            z-index: 200;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease-in-out;
        }

        .popup-modal-overlay.active {
            visibility: visible;
            opacity: 1;
        }

        /* Você também pode precisar ajustar o gist-modal-content para não ter margem superior extra */
        .popup-modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 90%; /* Ajusta a largura para ser responsiva, por exemplo, 90% */
            max-width: 400px; /* Mantém uma largura máxima para não ficar muito largo em telas grandes */
            height: auto; /* Permite que a altura se ajuste ao conteúdo */
            text-align: center; /* Centraliza o texto dentro do modal */
            margin-top: 5%; /* Adiciona uma margem do topo para que não cole na parte superior da tela */
            margin-bottom: 5%; /* Adiciona margem na parte inferior para respiro */
            overflow-y: auto; /* Adiciona rolagem se o conteúdo exceder a altura do modal */
            /* Remove 'max-width: 400px;' se você já tiver no .config-modal-content */
        }
        
        /* Estilos do Footer */
        footer {
            justify-content: center;
            width: 100%;
            padding: 15px 0;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
            font-size: 0.9em;
            color: white;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
            margin-top: 2rem; /* Pushes the footer to the bottom of the flex container */
        }
        
        /* @media (max-width: 768px) {
          .container {
            padding: 2rem 1.5rem;
            border-radius: 10px;
            height: 90%;
            max-height: 95%;
          }
        } */

        /* --- */
        #notification-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--cor-acento);
            color: var(--cor-texto);
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 1000;
        }
        
        #notification-box.show {
            opacity: 1;
        }

        #notification-box .close-btn {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1; /* Alinha o "x" verticalmente */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="section-title">
    		<h1>My Pomodorus</h1>
            <h2 id="relogio">00:00:00</h2>
        </div>
        
        <form>
            <div class="form-group">
                <label for="inicio">Início</label>
                <input type="time" id="inicio" name="inicio" required>
            </div>
            
            <div class="form-group">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <label>
                        <input type="radio" id="radioFim" name="modoPausa" value="fim" checked> Fim
                    </label>
                    <label>
                        <input type="radio" id="radioDuracao" name="modoPausa" value="duracao"> Duração
                    </label>
                </div>

                <div class="form-group" id="inputFimGroup">
                    <label for="fim">Fim</label>
                    <input type="time" id="fim" name="fim">
                </div>

                <div class="form-group" id="inputDuracaoGroup" style="display: none;">
                    <label for="duracao">Duração</label>
                    <input type="time" id="duracao" name="duracao">
                </div>
            </div>
            
            <button type="submit" class="btn-general">Criar</button>

            <div class="form-group" id="salvarPausasSection" style="display:none;">
                    <label for="tokenInput">Token das Pausas:</label>
                    <input type="text" id="tokenInput" name="token">
                    <p id="statusMessage" style="color:red; text-align:center; margin-top: 10px;"></p>
					<section class="buttons">
                    <button type="button" class="btn-general" id="copiarBtn">Copiar</button>
                    <button type="button" class="btn-general" id="fecharSalvarBtn">Fechar</button>
					</section>
            </div>
    
            <div class="form-group" id="carregarPausasSection" style="display:none;">
                    <label for="loadInput">Carregar Pausas:</label>
                    <input type="text" id="loadInput" name="load">
                    <p id="statusMessage" style="color:red; text-align:center; margin-top: 10px;"></p>
					<section class="buttons">
					<button type="button" class="btn-general" id="carregarTokenBtn">Carregar</button>
                    <button type="button" class="btn-general" id="fecharCarregarBtn">Fechar</button>
                    </section>
          	</div>
            
            <section class="buttons">
            <button type="button" class="btn-general" id="salvarPausasBtn">Salvar Pausas</button>

            <button type="button" class="btn-general" id="carregarPausasBtn">Carregar Pausas</button>
            </section>
            
			</form>
        
        <br>
        
        <section id="active-pauses">
            <h2 class="section-title">Pausas Ativas:</h2>
            <ul id="pauses-list"></ul>
        </section>
    </div>    

    <div class="popup-modal-overlay" id="popup-modal-overlay">
        <div class="popup-modal-content">
            <h3>Toque do alarme iniciado.</h3>
            
            <div class="buttons">
                <button id="popup-modal-stop-alarm" class="btn-general">Parar</button>                
        	</div>
        </div>
	</div>
	
    <footer>
        <p>&copy; 2025 MyPomodorus. Todos os direitos reservados - ZyonKing | Fontanari,C.</p>
    </footer>
    
<script src="https://cdn.jsdelivr.net/gh/zyon-king/MyPomodorus@main/frontend/db.js"></script>

<script src="https://cdn.jsdelivr.net/npm/appwrite@20.0.0"></script>
<script>

    // ===================
    // CONFIGURAÇÕES GLOBAIS
    // ===================
    // Coloque seus IDs aqui para facilitar a manutenção
    const PROJECT_ID = '686a67d5003a1b4b1bf9'; // SEU PROJECT ID
    const AGENDAR_FUNCTION_ID = '68cf1fc2002e437c4272';  // O ID da sua função de agendamento

    // ===================
    // INICIALIZAÇÃO APPWRITE
    // ===================
    const client = new Appwrite.Client()
    .setEndpoint('https://nyc.cloud.appwrite.io/v1')
    .setProject(PROJECT_ID);

    const account = new Appwrite.Account(client);
    const functions = new Appwrite.Functions(client);
    
    let currentUser = null;

    // Função para criar uma sessão anônima e obter o ID do usuário
    async function loginAnonimo() {
        try {
            currentUser = await account.get();
            console.log('Sessão existente para o usuário:', currentUser.$id);
        } catch (error) {
            try {
                await account.createAnonymousSession();
                currentUser = await account.get();
                console.log('Nova sessão anônima criada! ID do Usuário:', currentUser.$id);
            } catch (e) {
                console.error('Falha ao criar sessão anônima:', e);
            }
        }
    }

    // Função para registrar o Service Worker
    function registrarServiceWorker() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(reg => console.log('Service Worker registrado:', reg))
                .catch(err => console.error('Falha ao registrar Service Worker:', err));
        }
    }
// ===================
// Bloco - INICIALIZAÇÃO APPWRITE | Fim
// ===================
    let serviceWorkerAtivo = false;
        
    const notificationSound = new Audio('https://github.com/w3teal/awesome-ringtone/raw/refs/heads/main/Vivo/2022%20-%20Indomitable%20will.mp3'); // Certifique-se de ter um arquivo notification.mp3
    notificationSound.loop = true;
    
    const salvarBtn = document.getElementById('salvarPausasBtn');
    const carregarBtn = document.getElementById('carregarPausasBtn');
    const salvarSection = document.getElementById('salvarPausasSection');
    const carregarSection = document.getElementById('carregarPausasSection');

    const fecharSalvarBtn = document.getElementById('fecharSalvarBtn');
    const fecharCarregarBtn = document.getElementById('fecharCarregarBtn');

    salvarBtn.addEventListener('click', () => {
        salvarSection.style.display = 'block';
        carregarSection.style.display = 'none';
    });

    carregarBtn.addEventListener('click', () => {
        carregarSection.style.display = 'block';
        salvarSection.style.display = 'none';
    });

    fecharSalvarBtn.addEventListener('click', () => {
        salvarSection.style.display = 'none';
    });

    fecharCarregarBtn.addEventListener('click', () => {
        carregarSection.style.display = 'none';
    });
// ============================
// Permissão para Notificações
// ============================
async function solicitarPermissaoDeNotificacao() {
  // Verifica se o navegador suporta notificações
  if (!('Notification' in window)) {
    showNotification('Este navegador não suporta notificações de desktop.');
    return;
  }

  // Solicita a permissão. O navegador vai mostrar o popup.
  const permissao = await Notification.requestPermission();

  if (permissao === 'granted') {
    console.log('Permissão para notificações foi CONCEDIDA!');
  } else {
    console.log('Permissão para notificações foi NEGADA ou ignorada.');
    // Opcional: Mostrar uma mensagem mais amigável na tela
    // showNotification('Para receber os alarmes, por favor, habilite as notificações para este site nas configurações do seu navegador.');
  }
}

// Função unificada para disparar o alarme (Fallback)
function dispararNotificacao(title, body) {
    console.log(`FALLBACK: Disparando notificação - ${title}`);
    
    // 1. Tenta mostrar a notificação de desktop
    if (Notification.permission === "granted") {
        new Notification(title, {
            body: body,
            icon: "icon-192x192.png" // Opcional, mas recomendado
        });
    } else {
        console.log("Permissão de notificação não concedida, tocando apenas o som.");
    }

    // 2. Toca o som do alarme em todos os casos
    playNotificationSound();
}

// ===================
// Gerenciamento do Relógio
// ===================
function atualizarRelogio() {
    const agora = new Date();
    const horas = String(agora.getHours()).padStart(2, '0');
    const minutos = String(agora.getMinutes()).padStart(2, '0');
    const segundos = String(agora.getSeconds()).padStart(2, '0');
    
    document.getElementById('relogio').textContent = `${horas}:${minutos}:${segundos}`;

    const horaAtual = `${horas}:${minutos}`;
    
    // Verificar o início da pausa
    for (let i = pausas.length - 1; i >= 0; i--) {
        if (pausas[i].start === horaAtual && segundos === '00') {
            // Tocar o alarme para o início da pausa
            console.log(`Alarme! Início da pausa às ${horaAtual}.`);
            playNotificationSound();
            dispararNotificacao('Início da Pausa', `Sua pausa está começando agora!`);
            
            // Marca como iniciada (opcional)
            pausas[i].iniciada = true;
            renderPausas();
            continue; // Agora o continue está no lugar correto
        }

        // Lógica para verificar o fim da pausa
        if (pausas[i].end === horaAtual && segundos === '00') {
            // Tocar o alarme para o fim da pausa
            console.log(`Alarme! Fim da pausa às ${horaAtual}.`);
            playNotificationSound();
            dispararNotificacao('Fim da Pausa', `Sua pausa terminou. Hora de voltar!`);
            
            // Remover a pausa após tocar o alarme
            pausas.splice(i, 1);
            renderPausas();
        }
    }
}

// ===================
// Gerenciamento da Interface
// ===================
const radioFim = document.getElementById('radioFim');
const radioDuracao = document.getElementById('radioDuracao');
const inputFimGroup = document.getElementById('inputFimGroup');
const inputDuracaoGroup = document.getElementById('inputDuracaoGroup');
const inicioInput = document.getElementById('inicio');

// A função `toggleInputs` esconde ou mostra os campos de acordo com o rádio selecionado.
// CÓDIGO CORRIGIDO
function toggleInputs() {
    if (radioFim.checked) {
        // Altere 'block' para 'flex'
        inputFimGroup.style.display = 'flex'; 
        inputDuracaoGroup.style.display = 'none';
        document.getElementById('duracao').value = '';
    } else {
        inputFimGroup.style.display = 'none';
        // Altere 'block' para 'flex'
        inputDuracaoGroup.style.display = 'flex';
        document.getElementById('fim').value = '';
    }
}

// Adiciona os event listeners aos botões de rádio para gerenciar a interface.
radioFim.addEventListener('change', toggleInputs);
radioDuracao.addEventListener('change', toggleInputs);

// Também precisamos lidar com o cálculo da duração.
// Esta é uma função auxiliar para calcular a duração a partir do tempo de início e duração.
function calcularFimDeDuracao(inicio, duracao) {
    if (!inicio || !duracao) return '';

    const [startH, startM] = inicio.split(':').map(Number);
    const [durationH, durationM] = duracao.split(':').map(Number);
    
    let totalMinutosInicio = startH * 60 + startM;
    let totalMinutosDuracao = durationH * 60 + durationM;
    let totalMinutosFim = totalMinutosInicio + totalMinutosDuracao;
    
    let endH = Math.floor(totalMinutosFim / 60) % 24;
    let endM = totalMinutosFim % 60;

    return `${String(endH).padStart(2, '0')}:${String(endM).padStart(2, '0')}`;
}

// ===================
// Gerenciamento de Pausas
// ===================
// Este é o bloco anterior, mas com ajustes para os novos inputs de rádio.
// Certifique-se de que os IDs abaixo batem com os do seu HTML.
const pausaForm = document.querySelector('form'); // Seleciona o primeiro form
const pausesList = document.getElementById('pauses-list');
const duracaoInput = document.getElementById('duracao');
const fimInput = document.getElementById('fim');

let pausas = []; // Array para armazenar os objetos de pausa

function formatarTempo(minutos) {
    const horas = Math.floor(minutos / 60);
    const mins = minutos % 60;
    return `${String(horas).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
}

function calcularDiferencaEmMinutos(start, end) {
    let [startH, startM] = start.split(':').map(Number);
    let [endH, endM] = end.split(':').map(Number);
    
    let inicioMinutos = startH * 60 + startM;
    let fimMinutos = endH * 60 + endM;

    if (fimMinutos < inicioMinutos) {
        fimMinutos += 24 * 60;
    }

    return fimMinutos - inicioMinutos;
}

function renderPausas() {
    pausesList.innerHTML = '';
    if (pausas.length === 0) {
        pausesList.innerHTML = '<li style="text-align: center;">Nenhuma pausa ativa.</li>';
        return;
    }

    pausas.forEach((pausa, index) => { // Adicione o 'index' aqui
        const li = document.createElement('li');
        li.innerHTML = `
            ${pausa.start} - ${pausa.end} (${pausa.duration})
            <button class="remove-btn" data-index="${index}">Remover</button>
        `;
        pausesList.appendChild(li);
    });
}

pausesList.addEventListener('click', async (event) => { // <-- Adicione async aqui
    if (event.target.classList.contains('remove-btn')) {
        const index = event.target.dataset.index;
        const pausaParaRemover = pausas[index];
        
        // Só tenta deletar do DB se a pausa tem ID e as funções existem
        if (pausaParaRemover.id && typeof deletePausa === 'function') {
            await deletePausa(pausaParaRemover.id);
        }
        
        pausas.splice(index, 1);
        renderPausas();
    }
});

// ===========================
// addEventListener para Sw.js
// ===========================
pausaForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    if (!currentUser) {
        showNotification('Usuário não autenticado. Por favor, recarregue a página.');
        return;
    }

    if (Notification.permission !== 'granted') {
        showNotification('Para que os alarmes funcionem, você precisa permitir as notificações.');
        return;
    }

    const inicio = inicioInput.value;
    let fim = '';

    if (radioFim.checked) {
        fim = fimInput.value;
    } else {
        fim = calcularFimDeDuracao(inicio, duracaoInput.value);
    }

    if (!inicio || !fim) {
        showNotification('Por favor, preencha os horários da pausa.');
        return;
    }

    // --- LÓGICA DE AGENDAMENTO (continua igual) ---
    const inicioPayload = { title: 'Início da Pausa', body: `Sua pausa programada para as ${inicio} está começando!` };
    enviarMensagemParaSW(currentUser.$id, inicio, inicioPayload);

    const fimPayload = { title: 'Fim da Pausa', body: `Sua pausa programada terminou. Hora de voltar ao trabalho!` };
    enviarMensagemParaSW(currentUser.$id, fim, fimPayload);
    
    showNotification(`Pausa agendada com sucesso! Início: ${inicio} | Fim: ${fim}`);
    
    // =============================================================
    // ✅ CORREÇÃO: Salvar a nova pausa no IndexedDB
    // =============================================================
    const duracaoMinutos = calcularDiferencaEmMinutos(inicio, fim);
    const novaPausa = {
        id: Date.now(), // 1. Cria um ID único para a pausa
        start: inicio,
        end: fim,
        duration: formatarTempo(duracaoMinutos)
    };
    
    try {
        await addPausa(novaPausa);     // 2. SALVA a nova pausa no IndexedDB
        pausas.push(novaPausa);        // 3. Adiciona na lista da memória para exibição
        renderPausas();                // 4. Atualiza a tela
        console.log('Nova pausa salva no IndexedDB com sucesso!');
    } catch (error) {
        console.error('Falha ao salvar a nova pausa no IndexedDB:', error);
        showNotification('Erro ao salvar a pausa.');
    }
    // =============================================================

    gerarToken(); // A geração do token continua funcionando
});

// --- NOVA FUNÇÃO HELPER PARA CHAMAR O BACKEND ---
async function agendarNotificacao(userId, hora, payload) {
    // Converte a hora (ex: "14:30") para o formato de data completo UTC
    const [horas, minutos] = hora.split(':');
    const dataAlvo = new Date(); // Pega a data de hoje
    dataAlvo.setHours(horas, minutos, 0, 0); // Define a hora e minuto

    // Se o horário já passou hoje, agenda para o dia seguinte
    if (dataAlvo < new Date()) {
        dataAlvo.setDate(dataAlvo.getDate() + 1);
    }

    const targetTimeISO = dataAlvo.toISOString(); // Converte para "2025-09-20T17:30:00.000Z"

    try {
        console.log(`Enviando agendamento para ${targetTimeISO}...`);
        const resultado = await functions.createExecution(
            '68cf1fc2002e437c4272', // ID da sua função de agendamento
            JSON.stringify({
                userId: userId,
                targetTime: targetTimeISO,
                payload: payload
            })
        );
        console.log('Agendamento enviado com sucesso!', resultado);
        showNotification(`Alarme de ${payload.title.toLowerCase()} agendado para as ${hora}!`);
    } catch (error) {
        console.error('Falha ao agendar notificação:', error);
        showNotification('Ocorreu um erro ao agendar o alarme.');
    }
}

// ===================
// Geração e Processamento do Token
// ===================
const tokenInput = document.getElementById('tokenInput');
const loadInput = document.getElementById('loadInput');
const copiarBtn = document.getElementById('copiarBtn');
const carregarTokenBtn = document.getElementById('carregarTokenBtn');
const statusMessage = document.getElementById('statusMessage');

// Função para gerar o token com o novo padrão.
function gerarToken() {
    const pausasString = pausas.map(pausa => `${pausa.start}-${pausa.end}`).join(',');
    const token = `MyPomodorys(${pausasString})`;
    tokenInput.value = token;
}

// A função de processamento também precisa ser ajustada para remover o prefixo.
function processarToken(token) {
    const prefixo = 'MyPomodorys(';
    const sufixo = ')';

    // 1. Validar se o token começa e termina com o padrão esperado.
    if (!token.startsWith(prefixo) || !token.endsWith(sufixo)) {
        // ANTES: statusMessage.textContent = '...';
        showNotification('Erro: Padrão do token inválido. Use o formato MyPomodorys(...)');
        return null;
    }

    // 2. Extrair a parte do padrão que contém as pausas.
    const pausasToken = token.substring(prefixo.length, token.length - sufixo.length);
    const pausasString = pausasToken.split(',');
    const novoArrayDePausas = [];

    for (const pausaStr of pausasString) {
        const partes = pausaStr.split('-');
        if (partes.length !== 2) {
            // ANTES: statusMessage.textContent = '...';
            showNotification('Erro: Padrão de pausa inválido. Esperado "hh:mm-hh:mm".');
            return null;
        }

        const [inicio, fim] = partes;
        if (!/^\d{2}:\d{2}$/.test(inicio) || !/^\d{2}:\d{2}$/.test(fim)) {
            // ANTES: statusMessage.textContent = '...';
            showNotification('Erro: Formato de horário inválido (esperado hh:mm).');
            return null;
        }

        const duracaoMinutos = calcularDiferencaEmMinutos(inicio, fim);
        novoArrayDePausas.push({
            id: Date.now() + Math.random(), // Adiciona um ID único ao carregar
            start: inicio,
            end: fim,
            duration: formatarTempo(duracaoMinutos)
        });
    }

    return novoArrayDePausas;
}

copiarBtn.addEventListener('click', () => {
    gerarToken();
    tokenInput.select();
    document.execCommand('copy');
    // ANTES: statusMessage.textContent = 'Token copiado!';
    showNotification('Token copiado para a área de transferência!');
});

// PASSO 1: 'async' aqui
carregarTokenBtn.addEventListener('click', async () => { 
    const token = loadInput.value;

    // --- LÓGICA DE PERMISSÃO (está perfeita) ---
    if (Notification.permission !== 'granted') {
        showNotification('Para agendar, por favor, permita as notificações.');
        await solicitarPermissaoDeNotificacao(); 
        if (Notification.permission !== 'granted') {
            showNotification('A permissão é necessária para criar alarmes.');
            return;
        }
    }

    if (token) {
        const novoArrayDePausas = processarToken(token);
        if (novoArrayDePausas) {
            // Limpa as pausas antigas antes de carregar as novas
            for (const pausa of pausas) {
                await deletePausa(pausa.id);
            }

            pausas = novoArrayDePausas;

            // Salva e agenda as novas pausas
            for (const pausa of pausas) {
                await addPausa(pausa);
                
                const { start, end } = pausa;
                if (!currentUser) {
                    showNotification('Erro: Usuário não encontrado para agendar os alarmes.');
                    return;
                }
                const inicioPayload = { title: 'Início da Pausa', body: `Sua pausa programada para as ${start} está começando!` };
                enviarMensagemParaSW(currentUser.$id, start, inicioPayload);
                const fimPayload = { title: 'Fim da Pausa', body: `Sua pausa programada terminou. Hora de voltar!` };
                enviarMensagemParaSW(currentUser.$id, end, fimPayload);
            }

            renderPausas();
            // ANTES: statusMessage.textContent = '...';
            showNotification('Pausas carregadas e agendadas com sucesso!');
        }
    } else {
        // ANTES: statusMessage.textContent = '...';
        showNotification('Por favor, insira um token para carregar.');
    }
});

const popupModalOverlay = document.getElementById('popup-modal-overlay');
        const popupModalStopAlarmButton = document.getElementById('popup-modal-stop-alarm');
        
		// Inicia toque alarma, para atividade fundo
        function playNotificationSound() {

            popupModalOverlay.classList.add('active');
            if (notificationSound) {
                notificationSound.play().catch(e => console.error("Erro ao tocar o som da notificação:", e));
            }
        }

        // botão 'Parar' do popup
        popupModalStopAlarmButton.addEventListener('click', () => {
            notificationSound.pause();
            notificationSound.currentTime = 0;
            popupModalOverlay.classList.remove('active');
        });

        // fechar o popup clicando fora
        popupModalOverlay.addEventListener('click', (event) => {
            if (event.target === popupModalOverlay) {
                notificationSound.pause();
                notificationSound.currentTime = 0;
                popupModalOverlay.classList.remove('active');
            }
        });

// Função enviar Mensagem Para SW
// Função enviar Mensagem Para SW (Versão Corrigida e Simplificada)
function enviarMensagemParaSW(userId, hora, payload) {
  if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
    const [horas, minutos] = hora.split(':');
    const dataAlvo = new Date();
    dataAlvo.setHours(horas, minutos, 0, 0);
    if (dataAlvo < new Date()) {
      dataAlvo.setDate(dataAlvo.getDate() + 1);
    }

    navigator.serviceWorker.controller.postMessage({
      type: 'SCHEDULE_ALARM',
      userId: userId,
      time: dataAlvo.toISOString(),
      payload: payload
    });
    console.log(`Mensagem de agendamento para as ${hora} enviada para o Service Worker.`);
    // A LINHA PROBLEMÁTICA FOI REMOVIDA DAQUI
  } else {
    console.error('Service Worker não está ativo para agendar o alarme.');
    showNotification('Alarme salvo localmente. Service Worker não está ativo.');
  }
}

function showNotification(message) {
    const existingNotification = document.getElementById('notification-box');
    if (existingNotification) {
        existingNotification.remove();
    }

    const notificationBox = document.createElement('div');
    notificationBox.id = 'notification-box';
    notificationBox.textContent = message;

    // Cria e adiciona o botão de fechar
    const closeBtn = document.createElement('span');
    closeBtn.className = 'close-btn';
    closeBtn.innerHTML = '&times;'; // Usa o caractere 'x'
    notificationBox.appendChild(closeBtn);

    document.body.appendChild(notificationBox);

    // Força o navegador a aplicar o estilo inicial antes de adicionar a classe "show"
    getComputedStyle(notificationBox).opacity;
    notificationBox.classList.add('show');
           
    // Adiciona o evento de clique ao botão de fechar
    closeBtn.addEventListener('click', () => {
         // Limpa o temporizador para evitar que a notificação se feche sozinha
        notificationBox.classList.remove('show');
    });
}

// ===================
// Função de Inicialização
// ===================
async function init() {
    // 1. Primeiro, inicia a conexão com o banco de dados local
    try {
        await initDB();
        // 2. DEPOIS, busca as pausas que já estavam salvas
        pausas = await getAllPausas();
        // 3. SÓ AGORA, renderiza as pausas na tela
        renderPausas();
        console.log(`${pausas.length} pausas carregadas do IndexedDB.`);
    } catch (error) {
        console.error("Erro ao inicializar o banco de dados:", error);
    }
    
    // 4. O resto da inicialização continua normalmente
    toggleInputs();
    atualizarRelogio();
    setInterval(atualizarRelogio, 1000);
    
    // O ideal é pedir a permissão APENAS com um clique de botão, como discutimos
    // mas se quiser manter no init, tudo bem.
    await solicitarPermissaoDeNotificacao();
    
    await loginAnonimo();
    registrarServiceWorker();
}

// Aguardar o DOM estar pronto
document.addEventListener('DOMContentLoaded', init);

// E adicione esta nova função em algum lugar do seu script
function registrarServiceWorker() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        console.log('Service Worker registrado com sucesso:', registration);
        serviceWorkerAtivo = true; // <-- Adicione esta linha
      })
      .catch(error => {
        console.error('Falha ao registrar o Service Worker:', error);
      });
  }
}
</script>
</body>
</html>
